[toc]
# C++ 基础
## 关键字与运算符
### 引用与指针
1. 指针是存放某个地址的变量，本身有地址，所以可以有指向指针的指针。指针指向的地址可以变，同时他指向的地址的数据也可以变
2. 引用只是变量的别名，不能改变，而且必须初始化
3. 指向空值的引用是不存在的，指向空值的指针是存在的
   
### define 和 typedef 的区别
-  **define**:
    1. 只是简单的字符串替换, 没有类型检查
    2. 宏定义的，没有作用域限制，发生在预处理阶段，编译之前（也是为什么没有类型检查）
    3. 不分配内存，给出了就已经替换了
    4. 可以防止头文件重复引用。（头文件引用重复，a.h include b.h, b.h include c.h c.h include a.h）

``` cpp {line-numbers}
用法一:
#define int INTGER
用法二:
//使用#ifndef，#define，#endif，具体做法如下：
#ifndef HEAD_H
#define HEAD_H
// ……（头文件内容)
#endif
```


- **typedef**:
    1. 有对应的数据类型（包括自定义的数据类型），要进行判断的
    2. 在编译，运行中起作用
    3. 在静态存储区分配空间，程序运行过程中内存只有一个拷贝
```cpp {line-numbers}
typedef int INTEGER；  
INTEGER a,b;   // 以后就可用INTEGER来代替int作整型变量的类型
```

### define 和 inline 的区别
- **define**:  
    1. 预编译之前的宏，编译时不做类型检查，所以不安全  
    2. 仅为简单的字符串替换  
    3. 可用于避免重复引用
- **inline**:
    1. 如果一个函数内联，他会在编译时将这个函数的副本插入到被调用的地方，减少函数调用时压栈和弹栈的操作。提高效率，空间换时间。
    2. 一般内联的时比较小的代码
    3. 特殊的函数，会进行类型检查

- C++对inline函数的要求：
  1. 不能自己调用自己，也就是不能递归
  2. 代码长会导致空间占用
  3. 内联函数的声明必须在调用语句之前
  4. 不能存在过多的判断语句
### override(覆盖) 和 overload(重载)
- override 是覆盖一个方法（子类重写父类方法），通过关键字override可以直截了当的告诉编译器现在要重写一个基类(父类)里的方法。
 防止出现想要重载基类里的函数，但是在派生类中起错名的现象。如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。
    1. 被重写的方法不能是private(私有的)的
    2. 重写方法的传入参数，返回值和抛出的异常与重写方法一致，方法名称，参数类型，返回值类型全部相同。
    3. 被重写方法是静态的，那重写方法也一定是静态的
```cpp {line-numbers}
class Base {
public:
    virtual void print(void){...}
};
class Derived1 : public Base {
public:
    void print(void) override {...} // 明确告知重写
};
class Derived2 : public Base {
public:
    void Print(void) override {...}
};
```
- overload 是重载，同一作用域下，这些方法的名称相同而参数形式（传递的参数的个数或类型不同）不同。
   1. 无法通过访问权限，返回类型，抛出的异常来区分一组重载函数
   2. 不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序
```cpp {line-numbers}
#include<iostream>
using namespace std;
void print(int i)
{
        cout<<"print a integer :"<<i<<endl;
}
void print(string str)
{
        cout<<"print a string :"<<str<<endl;
}
int main()
{
        print(12);
        print("hello world!");
        return 0;
}
```
| 区别点	| 重载	| 重写（覆写）|
| :--------: | :-------: | :--------: |
|英文|	overloading|	overriding|
|定义|	方法名称相同，参数的类型或个数不同；对权限没有要求| 方法名称，参数类型，返回值类型全部相同|
|范围|	发生在一个类中 |	发生在继承类中|
### C++ 的内存分布
- 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区
  1. 栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值，操作方式与数据结构中的栈类似
  2. 堆区：malloc从堆上分配内存，堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。
  3. 自由存储区： new出来的内存块，由delete释放，new/delete会调用构造函数/析构函数对对象进行初始化与销毁。
  4. 全局/静态存储区：存放全局变量和静态变量
  5. 常量存储区：存放常量
### new 和 malloc
| 区别之处 | new/delete | malloc/free | 
| :------: | :------: | :------: |
|本质|运算符| C/C++标准的库函数|
|二者关系| 封装了malloc 
|分配空间| 无需指定大小 | 显式的分配大小|
|内存分配失败时|抛出bac_alloc异常,不会返回NULL | 会返回NULL|
|重载| 允许重载 | 不允许重载|
|申请的空间所在内存区| 在自由存储区 | 在堆区 |
|删除和创建类对象时| 会自动的调用析构函数和构造函数 |  不会调用析构函数和构造函数|

### const 和 constexpr
根据下面的程序，可以这样理解：
1. const 语义是只读，所以可以在运行时进行初始化。
2. constexpr 语义是常量（在初始化时就已经有值了, 自己理解为声明得到），所以编译时就要进行初始化。
``` cpp {line-numbers}
#include <iostream>
using std::cin;
int main()
{
    int i;
    cin >> i;
    const int j = i + 1; // right
    constexpr int j = i + 1; // error
}
```
### 常量指针(int* const e)和指针常量(const int\* d)
- 常量指针：具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针，称为指向常量的指针，简称常量指针。
- 指针常量：指针常量是指指针所指向的位置不能改变，即指针本身是一个常量，但是指针所指向的内容可以改变。
我觉得是“常量指针”和“指针常量”这样的翻译比较难记忆而已。
const 后面的不能改变
本质上是，1）常量指针：“被指向的对象是常量”；2）指针常量：“指针(地址)本身是常量”
我是这么理解的，*前面的是对被指向对象的修饰，*后面的是对指针本身的修饰。
常量指针：指向的地址（p）可以变，但是指向的值（\*p）不能变
指针常量：int\* 定义的是个地址，所以地址不能变（p）
```
// define
// 常量指针 
const int * p; // 指向的地址（p）可以变，但是指向的值（*p）不能变
int const * p; // 指向的地址（p）可以变，但是指向的值（*p）不能变
// 指针常量
int* const p; // int* 定义的是个地址，所以地址不能变（p）
```

### volatile
主要作用：防止编译器优化，每次都从内存中取出数据。
有些变量是用 volatile 关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入 CPU 寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile 的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，如下：
volatile 本意是要求每次读取此变量时，都要求再次读取，不允许用之前的值。我觉得就是限制编绎器，对于非嵌入式程序员的用户应该不大。打个比方，
例如在嵌入式编程中，读取串口数据时，串口的数据一直在变化
### extern
- 定义：声明外部变量，在函数或者文件外部定义的全局变量，声明extern关键字的全局变量和函数可以使它们可以跨文件访问。在别处定义，在此处声明，别处定义。

### static
- 当将局部变量声明为静态局部变量的时候，也就改变了局部变量的存储位置，即从原来的**栈**中存放改为**静态存储区**存放。这让它看起来很像全局变量，其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量**只在其被声明的代码块中是可见的**。不会随着程序的弹栈而消失。

### std::atomic
- 并发编程里的，先放一放
### 重载与重写
- 重载：函数名相同，参数列表和返回值不同
- 重写：函数名和参数列表和返回值相同
## C++三大特性
C++通过三种关键字来控制成员函数和成员变量的访问权限
- public:可以被任意实体访问
- protected:只允许子类及本类的成员函数，以及友元函数访问
- private:只允许本类的成员函数，友元函数访问

### 特性一：继承
让子类对象获得父类对象的属性和方法
- 继承的三种方式：
    1. 公有继承（public），不继承基类的私有成员，无法访问基类的私有成员，继承基类的成员，并继承其属性（在基类中私有，在派生类中也是私有）。在类外使用对象访问时，除了无法访问私有对象，也不能访问保护对象
    2. 私有继承（private），不继承基类的私有成员，将基类中的公有成员和私有成员转化派生类的私有成员。当在类外时，对象均不能访问基类的成员函数。
    3. 保护继承（protected）,基类中的public和protected成员均以protected的形式出现在派生类中。但是基类的private成员不可访问。对象均不能访问基类的成员函数。

### 特性二：封装
就是将事物封装成抽象的类。就是类。

### 特性三：多态
静态多态：函数重载和运算符重载
动态多态：有继承关系，子类重写父类的虚函数
父类的指针或引用指向子类,就会发生多态。多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类的对象。
加上virtual后，就会变成虚函数，那么编译器在编译的时候就不能确定函数调用，不会预先绑定父类的函数。
实现多态的两种方式
- 覆盖（override）:子类重写父类的虚函数
- 重载（overload）:允许存在多个同名函数
#### 虚函数
- 写了virtual关键字就代表这个函数在编译时无法确定，只有在运行时才被确定。多态就是一个指针指向子类对象，那么他调用的函数就是子类的对象的。
- 当基类希望派生类定义适合自己的版本，就将这些函数声明为虚函数（virtual）
- 虚函数依赖虚函数表工作，表存放虚函数地址。当我们用基类指针指向派生类时，虚表指针指向派生类的虚函数表。（翻译成人话就是：子类首先复制父类的虚函数表，然后用子类的虚函数表覆盖父类的虚函数表）
``` cpp
class Animal {
public:
    virtual void speak() {
        cout << "speak" << endl;
    }
}

class Cat :public Animal {
    void speak() {
        cout << "cat speak" << endl;
    }
}

void doSpeak(Animal& ani) { // 基类指针指向派生类
    ani.speak();
}

int main() {
    Cat cat;
    doSpeak(cat);
    // 另一种多态展现
    // Animal& animal = cat;
    // animal.speak(); 
}
```
虚函数指针指向虚函数表，虚函数表存放虚函数指针。
- 一般继承时，子类的虚函数表中先将父类虚函数放在前，再放自己的虚函数指针。派生类继承基类，并且重新定义了3个虚函数，派生类会自己产生一个兼容基类虚函数表的属于自己的虚函数表。基类的虚函数地址被拷贝到子类的虚函数表，派生类新增的虚函数置于虚函数表的后面，并按声明顺序存放。
- 如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置。
- 在多继承的情况下，每个父类都有自己的虚表，子类的成员函数被放到了第一个父类的表中。也就是说当类在多重继承中时，其实例对象的内存结构并不只记录一个虚函数表指针。基类中有几个存在虚函数，则子类就会保存几个虚函数表指针
- 也是把继承自父类的虚表中对应函数的索引的函数指针从父类函数改成了自己的函数

（优秀的解读）编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。
举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：
如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。
如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。

多类继承：
（1）每个继承的父类，都有自己的虚函数表；
（2）子类虚函数，放在第一个声明顺序的父类的表中


#### 构造函数不能是虚函数
- 创建一个对象时我们总是要明确指定对象的类型，而虚函数的实际类型是在运行期间确定的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。。。
- 没有构造出一个对象，对象就没有其所在的内存空间。而虚函数对应指向虚函数表的指针，这个首先放在内存空间里面的，对象没有实例化，就没有内存空间，找不到虚函数表。
- 从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数

#### 析构函数可以是虚函数
析构函数可以为虚函数，主要是基类指针指向子类对象的情况下，在基类销毁时，只调用基类的析构函数而不调用子类的析构函数，从而导致内存泄漏，所以需要虚函数机制来帮助系统' 识别 '需要释放资源。
若析构函数不是虚函数，delete 时，只有基类会被释放，而子类没有释放，从而存在内存泄漏的隐患。
没发生重写的话（没有加虚函数的话），就会调用父类的析构函数（为什么只调用父类的析构函数，因为如果父类指向子类时，只能调用自身函数和子类重写的函数，不能调用父类不存在，子类存在的函数。）


#### 为什么基类指针可以指向子类对象
可以指向，但是无法使用不存在于基类只存在于派生类的元素。
在内存中，一个基类类型的指针是覆盖N个单位长度的内存空间（指针存放的是首地址和数据长度）。
当其指向派生类的时候，由于派生类元素在内存中堆放是：前N个是基类的元素，N之后的是派生类的元素。
于是基类的指针就可以访问到基类也有的元素了，但是此时无法访问到派生类（就是N之后）的元素。

#### 纯虚函数
纯虚函数是在基类中声明的虚函数，它在基类中**没有定义**，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:
抽象类的定义： 称带有纯虚函数的类为抽象类, 他不能直接实例化，因为要实现虚函数继承
`virtual void funtion1()=0;//  虚函数必须实现，如果不实现，编译器将报错`

####  inline, static, constructor三种函数都不能带有virtual关键字。
- inline是在编译时展开，必须要有实体。而虚函数是在运行是才确定调用哪个虚函数，所以没法在编译时进⾏内联函数展开。
- 1）static(静态)函数是不和任何类对象或类实例相关联,所以就算给函数加上viruatl是没有任何意义的
2）虚函数依靠vptr和vtable来处理．vptr是一个指针，在类的构造函数中创建生成,并且只能用this去当问它，因为vptr是类的成员之一，并且vptr指向保存虚函数地址的vtable
3）对于静态成员函数，没有this指针，没有办法访问vptr
#### 静态与非静态成员函数之间有一个主要的区别
静态与非静态成员函数之间有一个主要的区别，就是静态成员函数可以不通过this指针来进行调用
#### 派⽣类的override虚函数定义必须和⽗类完全⼀致。
除了⼀个特例，如果⽗类中返回值是⼀个指针或引⽤，⼦类override时可以返回这个指针（或引⽤）的派⽣

为什么需要虚继承
- 解决多继承时的命名冲突和冗余数据，最典型的就是出现菱形继承时的情况
- 虚继承的目的是让某个类做出声明，无论之后出现了多少个基类，最终只存在一份
  
``` cpp 
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```
#### 抽象类和接口
- 类中至少一个函数被声明为纯虚函数`virtual int f()`
- 抽象类不能用于实例化对象
- 派生类如果继承抽象类，必须重写纯虚函数

## 智能指针
### 为什么要有智能指针
- 内存资源释放，但是指向它的指针没有改变指向（成为野指针），后续还在使用
- 内存资源释放，后期又试图再释放一次（重复释放造成崩溃）
- 没有及时释放内存资源，造成内存泄漏

为了能够实现堆内存的自动回收，C++增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。
能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏


### 底层实现
宏观智能指针实现：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。
shared_ptr实现：基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。采用引用计数的方法，申请内存堆内存创建对象时，会为其分配一个整型数，当有新对象使用使用此内存，整型数+1，当使用此内存的对象被释放时，该整型数-1，当整型数为0时，申请的内存空间被释放掉。

### auto_ptr被丢弃的原因
- 不能管理数组指针，当执行析构函数时，使用的是delete 而不是 delete[]， 导致仅仅删除了第一个元素，造成内存泄漏
不支持(拷贝构造函数)和赋值(operator = )，但赋值或复制的时候不会提示出错。因为不能被复制，所以不能被放入容器中。

### shared_ptr，在拷贝构造中使用同一份引用计数
- 允许多个指针指向一个对象

### 智能指针分类
- 三种智能指针，shared_ptr（共享指针）,unique_ptr（独占指针）,weak_ptr（弱指针）。
- 目的：为了解决动态分配内存导致的内存泄漏和多次释放同一内存，在C11标准中放在<memory\>头文件中
### unique_ptr
- 同一时刻只能有一个unique_ptr指向给定对象，离开作用域时，若其指向对象，则delete所指对象
- 定义unique_ptr 时，需要将其绑定在一个new返回的指针上
- unique_ptr不支持普通拷贝和赋值（因为拥有指向的对象），unique_ptr 不共享它的指针，所以没办法拷贝。
- 可以通过release和reset将控制权转移。见下代码

### shared_ptr的原理
A：shared_ptr维护了一个指向control block的指针对象，来记录引用个数。

### weak_ptr的原理
shared_ptr 会存在a引用b，b引用c的情况
A：weak_ptr用于避免shared_ptr相互指向产生的环形结构，造成的内存泄漏。weak_ptr count是弱引用个数；弱引用个数不影响shared count和对象本身，shared count为0时则直接销毁。
需要用一个shared_ptr实例来初始化weak_ptr，由于是弱共享，weak_ptr的创建并不会影响shared_ptr的引用计数值。

### 和shared_ptr指向相同的内存（如何判断weak_ptr指向对象是否存在）
shared_ptr析构后内存释放，在使用前使用函数lock()检查weak_ptr是否是空指针
如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr。
```
class A
{
public:
    A() : a(3) { cout << "A Constructor..." << endl; }
    ~A() { cout << "A Destructor..." << endl; }

    int a;
};

int main() {
    shared_ptr<A> sp(new A());
    weak_ptr<A> wp(sp);
    //sp.reset();

    if (shared_ptr<A> pa = wp.lock())
    {
        cout << pa->a << endl;
    }
    else
    {
        cout << "wp指向对象为空" << endl;
    }
}

```
### 如何判断weak_ptr的对象是否失效？
A：1、expired()：检查被引用的对象是否已删除。
2、lock()会返回shared指针，判断该指针是否为空。
3、use_count()也可以得到shared引用的个数，但速度较慢。

### shared_ptr 和 unique_ptr 区别
A：unique具有唯一性，对指向的对象值存在唯一的unique_ptr。unique_ptr不可复制，赋值，但是move()可以转换对象的所有权，局部变量的返回值除外。与shared_ptr相比，若自定义删除器，需要在声明处指定删除器类型，而shared不需要，shared自定义删除器只需要指定删除器对象即可，在赋值时，可以随意赋值，删除器对象也会被赋值给新的对象。
unique通过release或者reset可以将控制权进行转移
``` cpp
unique_ptr<string> u1(new string("hello ls"));
//将所有权从u1转移给u2;
unique_ptr<string> u2(u1.release());    //release将u1置空
unique_ptr<string> u3(new string("u3"));
//将所有权从u3转移给u2
u2.reset(u3.release());                 //reset释放了u2原来指向的内存

```
### 原因是什么？
A：unique的实现中，删除器对象是作为unique_ptr的一部分，而shared_ptr，删除器对象保存在control_block中。

## C++强制类型转换
关键词：static_cast, dynamic_cast, reinterpret_cast 和 const_cast

### 为什么要有这个强制类型转换
相比（）variable, 可维护性好，如果一个bug猜测是由类型转化造成的，那可以在windows中通过ctrl+f，在linux中使用grep中查找
### static_cast
- 没有运行时类型检查来保证转换的安全性
    - 进行上行转化，把派生类指针或引用转换为基类表示是安全的
    - 进行下行转换，把基类指针或引用转换为派生类表示，没有进行动态类型转换，所以不安全。
static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。

``` cpp
#include <iostream>
#include <cstdlib>
using namespace std;
class Complex{
public:
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:
    operator double() const { return m_real; }  //类型转换函数
private:
    double m_real;
    double m_imag;
};

int main(){
    //下面是正确的用法
    int m = 100;
    Complex c(12.5, 23.8);
    long n = static_cast<long>(m);  //宽转换，没有信息丢失
    char ch = static_cast<char>(m);  //窄转换，可能会丢失信息
    int *p1 = static_cast<int*>( malloc(10 * sizeof(int)) );  //将void指针转换为具体类型指针
    void *p2 = static_cast<void*>(p1);  //将具体类型指针，转换为void指针
    double real= static_cast<double>(c);  //调用类型转换函数
   
    //下面的用法是错误的
    float *p3 = static_cast<float*>(p1);  //不能在两个具体类型的指针之间进行转换
    p3 = static_cast<float*>(0X2DF9);  //不能将整数转换为指针类型
    return 0;
}
```
### const_cast 关键字
const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型

### reinterpret_cast 关键字
reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。
reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。

### dynamic_cast 关键字
有点，下行转换比static_cast更安全。
主要作用：安全的基类指针类型转化为派生类指针类型，dynamic_cast 会在程序运行期间借助 RTTI（RTTI是Runtime Type Identification的缩写，意思是运行时类型识别） 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。
dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。
[注] dynamic本身只能⽤于存在虚函数的⽗⼦关系的强制类型转换；对于指针，转换失败则返回nullptr，对于引⽤，转
换失败会抛出异常。
### RTTI（运行时类型识别）
RTTI是Runtime Type Identification的缩写，意思是运行时类型识别。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。但是现在RTTI的类型识别已经不限于此了，它还能通过typeid操作符识别出所有的基本类型（int，指针等）的变量对应的类型。

C++通过以下的两个操作提供RTTI：
（1）typeid运算符，该运算符返回其表达式或类型名的实际类型。
（2）dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。

## 字符串操作函数
### strcpy() 字符串复制函数
从地址的角度，把第二个字符串地址开始并含有'\0'结束符号的字符复制到以第一个字符数组开始的地址空间，返回值的类型为char*
该函数将第二个字符数组中的字符串复制到第一个字符数组，如果第一个字符数组中有内容的话，会被覆盖。
`char* strcpy(char *strDest, char *strSrc)`
#### strlen() 计算给定字符串的长度
`int strlen(const char *str)`

### strcat() 拼接字符串
将src所指的字符串添加到dest结尾处。
`char* strcat(char *dest, const char *src)`

### strcmp() 比较两个字符串
比较两个字符串str1, str2
字符串相同返回0，str1>str2返回正数，str1 < str2返回负数
`int strcmp(const char* str1, const char* str2)`

## C++内存模型
### 什么是内存泄露
内存泄漏，程序未能释放掉不再使用的内存。程序分配了内存后，由于设计错误，失去了对该段内存的控制，因此造成了内存的浪费。
可以使用Valgrind,mtrace进行内存泄漏检查
``` cpp
#include <mcheck.h>
void mtrace(void);
void muntrace(void);

// 调用方法：
mtrace(); // 开启内存追踪
// 代码块
mutrace(); // 关闭内存追踪
```
### 为什么可以说new申请的内存在堆上，也可以说在自由存储区上
- 自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
- 堆与自由存储区还是有区别的，它们并非等价。


### 内存泄漏的分类
- 堆内存泄漏（heap leak）
malloc从堆内分配的内存没有使用free释放掉
- 系统资源泄漏 (resource leak)
主要指使用系统分配的资源，比如Bitmap,handle,socket等没有使用相应的函数释放掉，导致系统资源浪费，严重可导致系统的效能降低，稳定性降低
- 没有将基类的析构函数定义为虚函数
  当基类的析构函数不是虚函数时，就不会调用起子类的析构函数，导致子类的内存无法释放

### 什么操作会导致内存泄漏
指针指向变化，未释放动态分配内存（new出来的对象1后，指针指向对象2，导致对象1没办法释放）

### 如何防止内存泄漏
将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使用智能指针

### 进程的地址空间分布
| 内存分配从上到下|
| :-----------------: |
|1G内核地址空间（0xFFFFFFFF-0xC0000000）|
|以下为3G的用户空间（0xBFFFFFFF）|
|(1)命令行参数和环境变量|
|(2)栈区|
|(3)共享区（文件映射区）|
|(4)堆区|
|(5)全局区（包括未初始化的bss区和已初始化的data区）|
|(6)代码区|


一个程序由命令行参数和环境变量，栈，文件映射区，堆，BSS段，数据段，代码段组成
1. 命令行参数与环境变量
  命令行参数是指从命令行执行程序的时候，给程序的参数
2. 栈区
  存放局部变量、函数参数值。栈从高地址向低地址增长，连续的空间
3. 文件映射区
  堆和栈之间
4. 堆区
   动态申请内存用，堆从低地址向高地址增长
5. BSS段
   存放程序中未初始化的全局变量和静态变量的一块内存区域
6. 数据段
   存放程序中已初始化的全局变量和静态变量的一块内存区域
7. 代码段
   存放程序执行代码的一块内存区域。只读，代码的头部还会包含一些只读的常数变量

### 说一说C与C++的内存分配方式
1. 从静态存储区分配
   内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，全局变量，静态变量
2. 栈上创建
   函数，函数内部的局部变量，函数运行结束释放
3. 从堆上分配（动态内存分配）
   程序在运行的时候使用new和malloc申请的内存，由delete和free释放

## 计算机的乱序执行（错序执行）
在这种范式中，处理器在一个由输入数据可用性所决定的顺序中执行指令，而不是由程序的原始数据所决定。在这种方式下，可以避免因为获取下一条程序指令所引起的处理器等待，取而代之的处理下一条可以立即执行的指令。
### 一定会按正常顺序执行的情况
- 对同一内存访问，此时访问的顺序不会被编译器修改
- 新定义的变量的值依赖于之前定义的变量，此时两个变量定义的顺序不会被编译器修改

### 其他情况计算机会进行乱序执行
单线程的情况下允许，但是多线程情况下产生问题。

### C++ 提供的六种内存模型
用于在多线程的情况下防止编译器的乱序执行


## 副作用
1. 无副作用编程
   存在一个函数，传一个参数x进去，计算得到一个y，中间所有的过程都是在栈内进行修改的.
2. 有副作用编程
   比如在一个函数运行的过程中对全局变量进行了修改
3. 在多线程程情况下的有副作用编程
   在显诚意运行的时候对成员变量进行了修改，此时如果在继续运行线程2，线程2拥有的就不是这个类的初始状态，运行出来的结果会收到线程1的影响
   解决方法，将成员方法设为const，此时就可以放心调用

## 信号量
CreateSemaphore（） 创建一个信号量  
OpenSemaphore（） 打开一个信号量  
ReleaseSemaphore（） 释放信号量 
WaitForSingleObject（） 等待信号量
对应操作系统的PV操作
PV操作及信号量的概念都是由荷兰科学家E.W.Dijkstra提出的。信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。  P操作 申请资源：  
（1）S减1；  
（2）若S减1后仍大于等于零，则进程继续执行；  
（3）若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。  
V操作 释放资源：  
（1）S加1；  
（2）若相加结果大于零，则进程继续执行；  
（3）若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。
### binary_semaphore
定义：可以当事件来用，只有有信号和无信号两种状态，一次只能被一个线程所持有。
使用步骤：
1）初始化创建信号量，并且一开始就将其设置为无信号状态`std::binary_semaphore sem(0);`
2）线程使用acquire()方法等待被唤醒
3)主线程种使用release()方法，将信号量变成有信号状态
### counting_semaphore
定义：一次可以被多个线程所持有
1）创建信号量
指定一次可以进入的线程的最大数量，并在最开始将其位置设置为无信号状态，`std::binary_semaphore<8> sem(0);`<font color="red"> 有问题 </font>
2）主线程中创建10个线程
待补充

## future 库
用于任务链 （即任务A的执行必须依赖任务B的返回值），异步调用，在等待程序响应，处理其他任务
1. 例子：生产者消费者问题
   1）子线程作为消费者
   参数是一个future,用这个future等待一个int型的产品，`std::future& fut`
   2）子线程中使用get()方法等待一个未来的future, 返回result.
   3） 待补充
2. 如果线程有返回值（<font color="red"> 目前还不懂，待补充 </font>）
    1）使用async方法进行异步执行
    参数1：可以选择马上执行，还是等一会执行（当消费者调用get()方法时开始执行）
    参数2：执行的内容（可以放一个函数对象或lambda表达式）
    2）生产者使用async方法做生产工作并返回一个future
    3）消费者使用future中的get()方法可以获取产品

## 运算符重载
首先理解运算符，运算符本质就是函数调用，如下所示
``` cpp
int c = data1 + data2;
// 等价下式
int c = operator+(data1, data2);
```

- 不建议重载的运算符：
   逗号，取值符；逻辑或，逻辑与；
- 运算符重载应该作为类的成员函数或者非成员函数(友元函数)

# C++ STL （标准模板库）
## STL实现原理及其实现
STL提供了六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器
- 容器（vector,list,deque,set,map）通过空间配置器去的数据存储空间
- 算法通过迭代器存储容器中的内容
- 仿函数可以协助算法完成不同的策略的变化（重载括号，使类能够像函数一样调用）
- 适配器可以修饰仿函数
## 容器
各种数据结构：顺序容器（vector,deque,list,forward_list,array,string）,关联性容器（map,set,multimap,multiset,unordered_map,unordered_set,unorder_multimap,unordered_multiset）。从实现角度来看，容器就是类模板

## 算法
sort,find,copy,for_each，从实现角度来看，STL算法是函数模板。

## 迭代器
通过迭代器可以遍历容器，五种类型：operator*, operator->,operator++,optrator-等指针相关操作予以重载的class template。

## 仿函数
重载operator()的class或者class template

## 适配器
一种用来修饰容器或者仿函数或迭代器接口的东西
STL提供queue和stack，虽然看似容器，但其实只能是一种容器适配器，底层借助deque和实现

## 空间配置器
负责空间的配置与管理，从实现老看，配置器是一个实现动态空间配置，空间管理，空间释放的类模板。
⼀般的分配器的std:alloctor都含有两个函数allocate与deallocte，这两个函数分别调⽤operator new()与
delete()，这两个函数的底层⼜分别是malloc()and free();但是每次malloc会带来格外开销（因为每次malloc⼀个元
素都要带有附加信息）

## map和unorder_map的区别
- map是红黑树的变体实现，unorder_map使用的是哈希表
- map具有自动排序的功能，因此所有元素都是有序的，操作map的元素其实是对红黑树进行操作
- 红黑树，一种平衡二叉树

## pair容器
保留两个数据成员，用于生成特定类型的模板
使用：`pair<T1, T2> p;` 利用->first和->second可以读取两个成员
用来遍历关联容器
``` cpp
// 循环遍历
#include <iostream>
#include <map>
using namespace std;
int main() {
	map<int,int> p;
	p[0] = 1;
	p[1] = 2;
	p[3] = 4;
	map<int,int>::iterator it;
	for(it = p.begin(); it != p.end(); it++) {
		cout<<it->first<<" "<<it->second<<endl;
	}
	return 0;
}
```
对map进行插入，元素类型是pair:
``` cpp
p.insert({"word", 1});
p.insert(pair<string, int>("word", 1));
```
## lamba 表达式
表示⼀个可调⽤的代码单元
Lambda表达式的完整声明格式如下：
```cpp
bool cmp(int a, int b)
{
    return  a < b;
}
对等与上述函数的lambda函数表达式
 // 模板：[capture list] (params list) mutable exception-> return type { function body };
 // 例子：
sort(lbvec.begin(), lbvec.end(), [](int a, int b) -> bool { return a < b; });
```
1. capture list：捕获外部变量列表
2. params list：形参列表
3. mutable指示符：用来说用是否可以修改捕获的变量
4. exception：异常设定
5. return type：返回类型
6. function body：函数体
通过省略某些成分来声明不完整的Lambda表达式：
``` cpp
// 省略1：
[capture list] (params list) -> return type {function body}
// 省略2：
[capture list] (params list) {function body}
// 省略3：
[capture list] {function body}
```
## vector容器的实现和扩充
### 底层实现
   在堆内分配一段连续的内存空间来存放元素，数据结构为线性空间，为了减少时间复杂度（插入元素开辟空间的时间成本），使其容量大于其大小。

### 扩容过程
如果集合已满，在新增数据的时候，分配一块更大的内存，将原来的数据复制过去，释放之前的内存，再插入新增的元素
所以对vector的任何操作，一旦空间重新分配，指向原始vector的所有迭代器都失效
### vec.size()和vec.capacity()
- 在堆内分配内存，元素连续存放，内存空间只会增长不会减少
- size()返回已经存储的数据个数
- capacity()返回不分配内存的情况下最多可以保存的元素个数
- 对于vector而言，capacity是永远大于等于size的
- capacity和size相等时，vector就会扩容，capacity变大

### vector扩容机制
不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。
#### 固定扩容
在原来的容量基础上加固定的容量，时间复杂度高，若每次固定加一容量，每次扩容都要增加
#### 加倍扩容
每次扩容的时候，原capacity翻倍，空间复杂度高

### resize()和reserve()
- resize:改变当前容器内含有元素的数量，而不是容器的容量
    - 当resize(len)中len>capacity() 则将size和capcity均设置为len
    - 当resize(len)中len<=capacity() 则将size设置为len
- reserve():改变当前容器的最大容量（capacity）
    - 如果reserve(len)的值 > 当前的capacity()，那么会重新分配⼀块能存len个对象的空间，然后把之前的对象通过copy construtor复制过来，销毁之前的内存;
    - 当reserve(len)中len<=当前的capacity()，则数组中的capacity不变， size不变，即不对容器做任何改变。
  
## list链表（双向链表）
每个元素都是放在一块内存的，但内存空间使不连续的，只能通过指针来进行数据的访问，或者通过迭代器的++实现
因为内存空间使不连续的，所以不需要移动内存，链表的插入和删除比较方便

## vector和list的区别
1. vector底层实现是数组，list是双向链表
2. vector是顺序内存，支持随机访问，list内存不连续，不支持随机访问
3. vector在中间节点进行插入和删除会导致内存的拷贝，list不会
4. vector一次性分配好内存，不够时才进行翻倍扩容，list每次插入都会进行内存申请
5. vector因为内存连续，所以查找比较快；list因为内存不连续，且只能由上一个节点找到下一个节点，所以查找慢
6. 因为内存连续，vector除了删除尾元素较快，其他位置的元素效率低（因为要移动其他元素）。而链表比较快，直接改变指向就行了，不需要移动其他单元

## deque 双端数组
和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。
deque采⽤⼀块map作为主控，其中的每个元素都是指针，指向另⼀⽚连续线性空间，称之为缓存区，这个区才是
⽤来储存数据的。<font color= "red"> 待补充 </font>
deque采用一块所谓的map作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。
自己复述：维持一个map，map里的节点是指针，指向一段连续存储空间（缓冲区），
### deque与vector区别
vector: 只能尾部插入和删除
deque: z支持双端插入和删除，⽀持快速随机访问，由于deque需要处理内部跳转，因此速度上没有vector快。

deque迭代器内部包含 4 个指针，它们各自的作用为：
cur：指向当前正在遍历的元素；
first：指向当前连续空间的首地址；
last：指向当前连续空间的末尾地址；
node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。

### deque数据结构:
deque除了维护⼀个map指针以外，还维护了start与finish迭代器分别指向第⼀缓冲区的第⼀个元素，和最后⼀个
缓冲区的最后⼀个元素的下⼀个元素，同时它还必须记住当前map的⼤⼩。具体结构和源代码看上⾯

### stack 和 queue (栈和队列)
栈和队列是由双端数组实现的
- 双端数组能实现4种操作，元素从头前出，从头前入，从尾部出，从尾部入；对应栈的先进后出和队列的先进先出

### 二叉树种类
#### 满二叉树
- 所有节点都有两个孩子或者没有
#### 完全二叉树
- 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
#### 二叉搜素树
- 节点的左孩子的值小于节点的值，节点的右孩子的值大于节点的值
#### 平衡二叉树
- 两个子树的高度差不超过1
#### 完美二叉树
- 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。

### heap 和 priority_queue 堆和优先队列
- heap(堆)：
建立在完全二叉树的基础上，分为大根堆（大的放前面）和小根堆。
- priority_queue(优先队列)
priority_queue 默认情况下，以vector 为底层容器，加上heap(默认max-heap) 处理规则；形成大根堆。
priority_queue 操作规则上是 queue，只允许在尾部加入元素，并从首部取出元素；只不过内部元素具有优先级，优先级高者先出。

```cpp
#include <queue>
using namespace std;
​
priority_queue<int> que;    //默认定义了最大堆，等同于将第三个参数使用less<int>
priority_queue<int, vector<int>, less<int>> que;  //定义大根堆
​
priority_queue<int, vector<int>, greater<int>> que;  //定义小根堆，VS下需要加入头文件#include<functional>
​
//测试 priority_queue<int> que;
que.push(3);
que.push(5);
que.push(4);
cout << que.top() << endl;  //5
​
//测试 priority_queue<int, vector<int>, less<int>> que;
que.push(3);
que.push(5);
que.push(4);
cout << que.top() << endl;  //5
​
//测试 priority_queue<int, vector<int>, greater<int>> que;
que.push(3);
que.push(5);
que.push(4);
cout << que.top() << endl;  //3
```

## map和set
- 都是C++关联容器，只是通过它提供的接口对元素访问，底层都是红黑树。
- set：用于判断某一个元素是否在同一个组
- map：字典
- 查找复杂度为O(logn)
- 每次插入时都要调整红黑树，效率有一定影响

## 为什么vector是以两倍的⽅式扩容⽽不是三倍四倍，或者其他⽅式呢
考虑可能产⽣的堆空间浪费，所以增⻓倍数不能太⼤，⼀般是1.5或2； GCC是2； VS是1.5， k =2 每次扩展的新尺⼨
必然刚好⼤于之前分配的总和，之前分配的内存空间不可能被使⽤，这样对于缓存并不友好，采⽤1.5倍的增⻓⽅
式可以更好的实现对内存的重复利⽤

## map和unordered_map
map中元素是一些key-value对，关键字起索引作用，值表示和索引相关的数据

### 底层实现
map底层是基于红黑树实现，因此map内部是有序的
unordered_map内部是杂乱无序的

### map优点和缺点
- 优点：有序性，map的查找，删除，增加的复杂度都是O(logn)
- 缺点：查找，删除，增加等操作平均时间复杂度较慢，与N有关

### unordered_map的优缺点
- 优点：哈希查找速度快，时间复杂度O(1)
- 缺点：内部基于哈希表，以(key,value)对的形式存储，因此空间占用率高。

## .C 文件的编译过程？
预处理：宏替换、条件编译、删除注释、展开头文件
编译：代码转汇编、词法分析、语法分析、符号汇总
汇编：汇编转机器码、生成符号表（符号表的查看方式 readelf）

## 泛型编程
模板分类：类模板和函数模板，特化为特例化和部分特例化
对象模板特例化是因为对特定类型，可以利用
全特化：限定死模板实现的具体类型
偏特化：如果模板有多个类型，只限定其中的一部分
模板分为类模板与函数模板，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。

类模板的全特化和偏特化
``` CPP
template<typename T1, typename T2>
class Test
{
public:
    Test(T1 i,T2 j):a(i),b(j){cout<<"模板类"<<endl;}
private:
    T1 a;
    T2 b;
};

template<>
class Test<int , char>
{
public:
    Test(int i, char j):a(i),b(j){cout<<"全特化"<<endl;}
private:
    int a;
    char b;
};

template <typename T2>
class Test<char, T2>
{
public:
    Test(char i, T2 j):a(i),b(j){cout<<"偏特化"<<endl;}
private:
    char a;
    T2 b;
};
int main() {
    Test<double , double> t1(0.1,0.2); // 类模板
    Test<int , char> t2(1,'A'); // 全特化
    Test<char, bool> t3('A',true); // 偏特化
}
```
函数模板只能全特化，不能偏特化
代码：
``` cpp
//模板函数
template<typename T1, typename T2>
void fun(T1 a , T2 b)
{
    cout<<"模板函数"<<endl;
}

//全特化
template<>
void fun<int ,char >(int a, char b)
{
    cout<<"全特化"<<endl;
}

//函数不存在偏特化：下面的代码是错误的
/*
template<typename T2>
void fun<char,T2>(char a, T2 b)
{
    cout<<"偏特化"<<endl;
}
*/
```
### 为什么要进行模板特例化
因为全的模板里的代码不能处理全部的情况，下列完美说明为什么要进行特例化
``` cpp
// 当使用一个判断相等的模板函数时
template<class T>
bool Isequal(T& p1, T& p2){
	return p1 == p2;
}
// 但是该模板函数在对于字符串进行比较时就不能使用了，对于字符串我们不能直接比较，因此直接特化出一个专门供字符串使用的模板参数

template<> // 此处不添加类型模板，直接使用空即可
bool Isequal<char*>(char*& p1, char*& p2){
	return strcmp(p1, p2) == 0;
}
```
- 使用模板特例化必须要有基础的模板，对主版本模板类、全特化类、偏特化类的调⽤优先级从⾼到低进⾏排序是：全特化类>偏特化类>主版本模板类。
### 为什么函数不能使用偏特化
函数模板，只有全特化，偏特化的功能可以通过函数重载完成。

# C++11新特性
## 类型推导
### auto：
可以让编译器在编译期就推导出变量的类型
- auto不能定义数组，能定义指针
### decltype:
由下面例子可以看到，decltype 能够根据变量、字面量、带有运算符的表达式推导出变量的类型。
```
返回表达式的类型
int a = 0;
decltype(a) b = 1;  //b 被推导成了 int
decltype(10.8) x = 5.5;  //x 被推导成了 double
decltype(x + 100) y;  //y 被推导成了 double
```
## 左值引用和右值引用
### 前置++ 和 后置++
前置++的效率更高，理由是：后置++会生成临时对象。后置是调用前置实现


```
	class Age   
	{   
	public:   
	    Age& operator++() {  //前置++   
	        ++i;   
	        return *this;   
	    }   
	    const Age operator++(int)  { //后置++   
	        Age tmp = *this;   
	        ++(*this);  //利用前置++   
	        return tmp;   
	    }   
	    Age& operator=(int i) {   //赋值操作   
	        this->i = i;   
	        return *this;   
	    }   
	private:   
	    int i;   
	}; 
```

### 左值和右值
- 左值是可以写在=号左边的表达式，必须是一个非const的变量。
- 右值是可以写在=号右边的表达式，可以是一个常量,一个字面数字，或者说一个任意的可以求值的表达式。一个可以作为左值的表达式,同时也是可以作为右值使用的
- ++i,--i是左值，i++,i--是右值

### 左值引用和右值引用
在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址，表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
左值引用：
- 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用于引用；
- 但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。
右值引用：
C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法：
可以取地址的，有名字的，非临时的就是左值；
不能取地址的，没有名字的，临时的就是右值；
可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const对象等都是左值。

右值引用的作用：
是临时变量的寿命延长，减少不必要的拷贝构造，直接让右值指向临时变量。

自己理解：
```cpp
int get_return() {
	int b = 3;
	return b;
}
int main() {
    int a = get_return(); //将函数返回值进行拷贝，拷贝到左值a，然后销毁临时变量b.
    int&& c = get_return(); // 将函数返回值绑定到c上（c是b的引用），延长临时变量b的寿命
}
```

``` cpp
// 定义右值引用的格式如下：
// 类型 && 引用名 = 右值表达式;
int &&var = 10;

```
### 左值引用
对左值（可以取地址的数）进行的引用，是对象的一个别名
### 右值引用
表达式等号右边的值需要是右值，可以使用std::move强制将左值转换为右值
### 移动语义
窃取资源，通过移动构造函数使用移动语义，也就是std::move

### 浅拷贝
a和b指针指向同一块内存，就是浅拷贝。
### 深拷贝
如果有指针指向这个单元，复制时就再开辟一个新的内存存储资源

### 完美转发

完美转发使用两步来完成任务：
写⼀个接受任意实参的函数模板，并转发到其它函数，⽬标函数会收到与转发函数完全相同的实参，通过std::forward()实现
在模板中使用&&接收参数。
使用std::forward()转发给被调函数.
这样左值作为仍旧作为左值传递，右值仍旧作为右值传递！

### NULL和nullptr和0
- nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。
- NULL就是0，在C++11之后
- C++引入nullptr关键字区分空指针和0，nullptr的类型为nulptr_t,能够转化为任意指针或成员指针的类型，也可以进行相等或不等的比较。

# 并发
## std::thread

## lock_guard
ock_guard是一个互斥量包装程序，
创建lockguard对象时，它尝试获取提供给他的互斥锁的所有权，离开时释放
1. 创建就加锁，作用域结束自动析构并解锁，无需手工解锁
2. 不能中途解锁，必须等作用域结束才解锁
3. 不能复制

### unique_lock
通用的互斥量锁定包装器，允许延迟锁定，限时深度锁定，递归锁定，锁定所有权的转移以及与条件变量⼀起使⽤。
特点如下：
1. 创建时可以不锁定（通过指定第⼆个参数为std::defer_lock），⽽在需要时再锁定
2. 可以随时加锁解锁
3. 作⽤域规则同 `lock_grard`，析构时⾃动释放锁
4. 不可复制，可移动
5. 条件变量需要该类型的锁作为参数（此时必须使⽤unique_lock）

# 操作系统
## 进程和线程有什么区别
官方：进程是资源分配的最小单元，线程是CPU调度的最小单元
具象：进程是火车，线程是车箱
进程时一个执行任务（控制单元）负责当前进程的执行，一个进程至少有一个线程
- 不同进程数据很难共享
- 同一进程下不同的线程间数据很容易共享
- 进程间不会影响，一个进程挂了也不一定会影响其他的线程，但是一个线程挂了会影响整个进程
- 进程之间可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束
- 进程拥有系统资源的独立单元，而线程只拥有一些不可少的资源（程序计数器，一组寄存器和栈），和其他线程共享本进程的相关资源
- 进程切换时，涉及环境变量和CPU调度设置，而线程切换只需要保存和设置少量的寄存器内容，并不涉及存储器管理方面的操作。
个人汇总：
- 进程就是一个正在运行的程序，有了线程技术，我们就可以在一个进程中创建多个线程，让它们在“同一时刻”分别去做不同的工作了。这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步
## 同一进程中的线程可以共享哪些数据？
- 进程代码段
- 进程的公共数据（全局变量和静态变量）
- 进程打开的文件描述符
- 进程的当前目录
- 信号处理器，对收到的信号的处理
- 进程ID和进程组ID
## 线程独占哪些资源？
- 线程ID
- 一组寄存器的值
- 线程自身的栈（线程运行时的函数调用），放在堆里的是共享的
- 错误返回码，线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其他线程修改
- 信号掩码/信号屏蔽字：表示是否屏蔽/阻塞相应的信号

## 进程通信IPC（InterProcess Communication）方式
### 为什么进行进程通信
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走；内核提供的这种机制成为进程间通信。
### 管道
管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，一端写入缓冲区，一端从缓冲区读取数据
### 消息队列
存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。
### 信号（Signal）
信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
### 共享内存
使得多个进程可以可以直接读写同一块内存空间，是**最快的**可用IPC形式。是针对其他通信机制运行效率较低而设计的。
### 信号量(semaphore)
原子操作，传递数据需要结合共享内存
信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
为了获得共享资源，进程需要执行下列操作（三个操作，初始化操作，P操作，V操作）：
（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
（2）等待一个信号量：信号量-1，测试这个信号量的值，如果小于0，就阻塞进程。也称为P操作。（使S=S-1，若S>=0，则该进程继续执行，否则该进程排入等待队列。）
（3）挂出一个信号量：信号量的值加1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪状态，也称为V操作。（使S=S+1，若S>0,唤醒等待队列中的一个进程）
### 套接字（Socket）
不同机器之间的进程通信
Socket由三个属性确定：域，端口号，协议类型
- 套接字通信的建立
  - 客户端 
    1. 客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。
    2. 一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。
   - 服务端
    1. 首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。
    2. 然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。
    3. 接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。
    4. 最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。

## 进程同步问题
进程的同步是目的，而进程间通信是实现进程同步的手段

### 管程（Monitor）
 - 信号量能实现的管程都能实现
 #### 为什么要引入管程
  信号量机制是一种方便有效的进程同步工具。但每次访问临界资源时都需要进程自身进行wait(S)和signal(S)操作。大量的同步操作分散在不同进程中，会给系统管理带来负担，另一方面同步操作使用不当容易导致死锁。

 #### 条件变量
 为什么存在：当进程调用管程，在管程过程中被阻塞或挂起，若一直不释放管程，则其他进程无法进入，被迫长时间等待。所以为了让进入管程而无法继续执行的进程阻塞自己。

 #### 管程的操作
    当一个进程试图进入管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在紧急等待队列中等待。

### 临界区的概念
各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段
每个进程中访问临界资源的那段代码称为临界区。每次只允许一个进程进入临界区，进入后，不允许其他进程进入。显然，若能保证进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。
#### 临界资源
 临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方法，实现共享的资源称作临界资源。
### 同步与互斥的概念
 - 同步：不是不是不是一起走，是不同进程的若干个程序片段，当某个进程运行其中的一个程序片段时，其他进程就不能运行他们中的任意程序片段，只能等到该进程运行完这个程序片段后才可以运行。指这些程序按照一定的先后顺序运行。
  自己理解：两个以上的进程不能同时进行，需要按照顺序进行。
 - 互斥：多个进程在同一时刻只有一个进程能进入临界区，从资源分配的角度，某一资源同时只允许一个访问者对其进行访问，

### 并发，并行和异步
- 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
- 并发：在一个时间段中同时有多个程序运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；（是不是时间片轮转算法）
- 并行：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的

### 进程有哪些状态？
- 就绪状态：进程已获得除处理机外的所需资源，等待分配处理机资源